{"version":3,"file":"static/js/786.7eac8dff.chunk.js","mappings":"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","sources":["config/index.ts","services/ipfsService.ts"],"sourcesContent":["/**\r\n * Configuration helper for automatic environment detection\r\n */\r\n\r\nexport const config = {\r\n  /**\r\n   * Get the appropriate backend URL based on environment\r\n   */\r\n  getBackendUrl: (): string => {\r\n    // Always try production URL first if it's available\r\n    const productionUrl = process.env.REACT_APP_BACKEND_URL_PRODUCTION;\r\n    const developmentUrl = process.env.REACT_APP_BACKEND_URL_DEVELOPMENT || 'http://localhost:3001';\r\n    \r\n    // If we have a production URL and it's not a placeholder, try it first\r\n    if (productionUrl && productionUrl !== 'https://your-railway-app.up.railway.app') {\r\n      return productionUrl;\r\n    }\r\n    return developmentUrl;\r\n  },\r\n\r\n  /**\r\n   * Check if we're in development mode\r\n   */\r\n  isDevelopment: (): boolean => {\r\n    return process.env.NODE_ENV !== 'production' && \r\n           window.location.hostname === 'localhost';\r\n  },\r\n\r\n  /**\r\n   * Get all possible backend URLs to try (in priority order)\r\n   */\r\n  getAllBackendUrls: (): string[] => {\r\n    return [\r\n      process.env.REACT_APP_BACKEND_URL_PRODUCTION,\r\n      process.env.REACT_APP_BACKEND_URL_DEVELOPMENT,\r\n      'http://localhost:3001',\r\n      'http://localhost:3002'\r\n    ].filter(Boolean).filter(url => url !== 'https://your-railway-app.up.railway.app') as string[];\r\n  }\r\n};\r\n\r\nexport default config;","/**\r\n * API Service for NFT storage via backend\r\n */\r\nimport { config } from '../config';\r\n\r\nexport interface UploadResult {\r\n  success: boolean;\r\n  hash?: string;\r\n  url?: string;\r\n  error?: string;\r\n  // Additional properties for NFT upload\r\n  imageHash?: string;\r\n  imageUrl?: string;\r\n  metadata?: NFTMetadata;\r\n}\r\n\r\nexport interface NFTUploadData {\r\n  imageFile: File | Blob;\r\n  metadata: NFTMetadata;\r\n}\r\n\r\nexport interface NFTMetadata {\r\n  name: string;\r\n  description: string;\r\n  image?: string;\r\n  attributes: Array<{ trait_type: string; value: string }>;\r\n  external_url: string;\r\n  created_at: string;\r\n}\r\n\r\nclass APIService {\r\n  private baseUrl: string;\r\n\r\n  constructor() {\r\n    this.baseUrl = config.getBackendUrl();\r\n  }\r\n\r\n  /**\r\n   * Enhanced availability check with automatic URL discovery\r\n   */\r\n  async isAvailable(): Promise<boolean> {\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/health`, {\r\n        method: 'GET',\r\n        signal: AbortSignal.timeout(5000) // 5 second timeout\r\n      });\r\n      \r\n      if (response.ok) {\r\n        return true;\r\n      }\r\n    } catch (error) {\r\n      // Backend not available, will try fallbacks\r\n    }\r\n\r\n    // If primary URL fails, try fallback discovery\r\n    return await this.tryFallbackUrls();\r\n  }\r\n\r\n  /**\r\n   * Try alternative URLs if primary fails\r\n   */\r\n  private async tryFallbackUrls(): Promise<boolean> {\r\n    const fallbackUrls = config.getAllBackendUrls();\r\n\r\n    for (const url of fallbackUrls) {\r\n      if (url === this.baseUrl) continue; // Skip already tried URL\r\n      \r\n      try {\r\n        const response = await fetch(`${url}/health`, {\r\n          method: 'GET',\r\n          signal: AbortSignal.timeout(3000)\r\n        });\r\n        \r\n        if (response.ok) {\r\n          this.baseUrl = url; // Update to working URL\r\n          return true;\r\n        }\r\n      } catch (error) {\r\n        // Fallback URL failed, try next\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Upload complete NFT data (image + metadata) in one call\r\n   */\r\n  async uploadNFT(data: NFTUploadData): Promise<UploadResult> {\r\n    try {\r\n      const formData = new FormData();\r\n      formData.append('image', data.imageFile);\r\n      formData.append('metadata', JSON.stringify(data.metadata));\r\n\r\n      const response = await fetch(`${this.baseUrl}/api/upload-nft`, {\r\n        method: 'POST',\r\n        body: formData\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Upload failed: ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n      \r\n      if (!result.success) {\r\n        throw new Error(result.error || 'Upload failed');\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('NFT upload error:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown upload error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Upload just an image file\r\n   */\r\n  async uploadImage(file: File | Blob): Promise<UploadResult> {\r\n    try {\r\n      const formData = new FormData();\r\n      formData.append('file', file);\r\n\r\n      const response = await fetch(`${this.baseUrl}/api/upload-file`, {\r\n        method: 'POST',\r\n        body: formData\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Image upload failed: ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n      \r\n      if (!result.success) {\r\n        throw new Error(result.error || 'Image upload failed');\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Image upload error:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown image upload error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Upload metadata JSON\r\n   */\r\n  async uploadMetadata(metadata: NFTMetadata): Promise<UploadResult> {\r\n    try {\r\n      const response = await fetch(`${this.baseUrl}/api/upload-metadata`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ metadata })\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Metadata upload failed: ${response.statusText}`);\r\n      }\r\n\r\n      const result = await response.json();\r\n      \r\n      if (!result.success) {\r\n        throw new Error(result.error || 'Metadata upload failed');\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Metadata upload error:', error);\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown metadata upload error'\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const apiService = new APIService();\r\n\r\n/**\r\n * Helper function to create NFT metadata\r\n */\r\nexport const createNFTMetadata = (\r\n  name: string,\r\n  description: string,\r\n  imageUrl: string,\r\n  attributes: Array<{ trait_type: string; value: string }>\r\n): NFTMetadata => {\r\n  return {\r\n    name,\r\n    description,\r\n    image: imageUrl,\r\n    attributes,\r\n    external_url: window.location.origin,\r\n    created_at: new Date().toISOString()\r\n  };\r\n};\r\n\r\n/**\r\n * Check if IPFS storage is configured (backend available)\r\n */\r\nexport const isStorageAvailable = async (): Promise<boolean> => {\r\n  return await apiService.isAvailable();\r\n};\r\n\r\n// Legacy exports for compatibility (deprecated)\r\n/** @deprecated Use apiService.uploadImage instead */\r\nexport const uploadToIPFS = apiService.uploadImage.bind(apiService);\r\n\r\n/** @deprecated Use apiService.uploadMetadata instead */\r\nexport const uploadMetadataToIPFS = apiService.uploadMetadata.bind(apiService);\r\n\r\n/** @deprecated Use isStorageAvailable instead */\r\nexport const getIPFSConfig = () => ({ configured: true });\r\n"],"names":["config","getBackendUrl","productionUrl","process","isDevelopment","getAllBackendUrls","filter","Boolean","url","apiService","constructor","baseUrl","this","isAvailable","fetch","concat","method","signal","AbortSignal","timeout","ok","error","tryFallbackUrls","fallbackUrls","uploadNFT","data","formData","FormData","append","imageFile","JSON","stringify","metadata","response","body","Error","statusText","result","json","success","console","message","uploadImage","file","uploadMetadata","headers","createNFTMetadata","name","description","imageUrl","attributes","image","external_url","window","location","origin","created_at","Date","toISOString","isStorageAvailable","async","uploadToIPFS","bind","uploadMetadataToIPFS","getIPFSConfig","configured"],"sourceRoot":""}